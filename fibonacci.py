import math


# Compute n! (n factorial) using the built-in math.factorial function
def finonacci_factorial(n):
    # Delegate the computation to math.factorial, which efficiently computes n!
    return math.factorial(n)


#Generate series

def finonacci_series(n):
    # Initialize the list that will store the Fibonacci series
    series = []

    # Handle the case n == 0: only F(0) = 0
    series.append(0)
    if n == 0:
        return series
    # Handle the case n >= 1: append F(1) = 1
    series.append(1)
    if n == 1:
        return series
    
    # For n >= 2, iteratively compute each next Fibonacci number
    # using: F(k) = F(k-1) + F(k-2)
    for i in range (2,n+1):
       series.append(series[i-1]+series[i-2])
    return series

# Compute n! (n factorial) using iterative multiplication
def finonacci_mutiply(n):
   # Initialize the accumulator for the product (will store n!)
    total = 1

    # Multiply all integers from 1 up to n (inclusive)
    for i in range(1, n + 1):
        total *= i

    # Return the final product, which is n! (n factorial)
    return total



# Main function for user interaction
def main():
    while True:
        try:
            input_variable = int(input('Please input a positive number: '))
            if input_variable < 0:
                print(f"This is a negative number")
                break

             # Print all Fibonacci numbers generated by the dynamic approach
            print('Fibonacci series is ',end="")
            print('{', end='')
            print( *finonacci_series(input_variable), sep=', ',end='')
            print('}')

            
            print(f'The n! using iterative multiplication is {finonacci_mutiply(input_variable)}') 

            print(f'The n! using math is {finonacci_factorial(input_variable)}') 
    
            
        except ValueError:
            print("WARNING: This is not an integer! Please input again", end="")


if __name__ == "__main__":
    # Call main function to start Fibonacci program
    main()
