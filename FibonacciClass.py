import math

class FibonacciClass:

    def __init__(self,n):
        self.n= n
    def fibonacci_series_math(self):
        series=[]
        # Golden ratio (φ), approximately 1.618...
        a = (1 + math.sqrt(5)) / 2  

        # Conjugate of the golden ratio (1 - φ), approximately -0.618...
        b = (1 - math.sqrt(5)) / 2  

        # Apply Binet's formula to compute the n-th Fibonacci number:
        # F(n) = (φ^n - (1 - φ)^n) / √5
        # Because of floating-point precision issues, we use round() 
        # to get the nearest integer as the final Fibonacci number.
        series=[round((math.pow(a, i) - math.pow(b, i)) / math.sqrt(5)) for  i  in range(0,self.n+1)]
        return  series;

    # Compute n! (n factorial) using the built-in math.factorial function
    def finonacci_factorial(self):
        # Delegate the computation to math.factorial, which efficiently computes n!
        return math.factorial(self.n)


    #Generate series

    def finonacci_series(self):
        # Initialize the list that will store the Fibonacci series
        series = []

        # Handle the case n == 0: only F(0) = 0
        series.append(0)
        if self.n == 0:
            return series
        # Handle the case n >= 1: append F(1) = 1
        series.append(1)
        if self.n == 1:
            return series
        
        # For n >= 2, iteratively compute each next Fibonacci number
        # using: F(k) = F(k-1) + F(k-2)
        for i in range (2,self.n+1):
            series.append(series[i-1]+series[i-2])
        return series

    # Compute n! (n factorial) using iterative multiplication
    def finonacci_mutiply(self):
    # Initialize the accumulator for the product (will store n!)
        total = 1

        # Multiply all integers from 1 up to n (inclusive)
        for i in range(1, self.n + 1):
            total *= i

        # Return the final product, which is n! (n factorial)
        return total

    # @staticmethod
    def factorial_recursion(self,n):
        """
        Compute the factorial of n recursively.
        
        Args:
            n (int): Non-negative integer

        Returns:
            int: n! (factorial of n)
        """
        # Base case: factorial of 0 is 1
        if n == 0:
            return 1
        
        # Recursive case: n! = n * (n-1)!
        return n * self.factorial_recursion(n-1)



if __name__ == "__main__":
    # Call main function to start Fibonacci program
   while True:
        try:
            input_variable = int(input('Please input a positive number: '))
            if input_variable < 0:
                print(f"This is a negative number")
                break
            fib_instance = FibonacciClass(input_variable)
            print(f'The n! using iterative multiplication is {fib_instance.finonacci_mutiply()}') 
             # Print all Fibonacci numbers generated by the dynamic approach
            print('Fibonacci series is ',end="")
            print('{', end='')
            print( *fib_instance.finonacci_series(), sep=', ',end='')
            print('}')

            
           

            print(f'The n! using math is {fib_instance.finonacci_factorial()}') 
    
            # Print all Fibonacci numbers generated by the dynamic approach
            print('Fibonacci series through math is ',end="")
            print('{', end='')
            print( *fib_instance.fibonacci_series_math(), sep=', ',end='')
            print('}')

            print(f'The n! using recursion is {fib_instance.factorial_recursion(input_variable)}') 
            
        except ValueError:
            print("WARNING: This is not an integer! Please input again", end="")

